---
phase: 04-visualization-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/components/diagrams/DiagramCanvas.svelte, src/lib/components/diagrams/SVGContainer.svelte, src/lib/components/diagrams/index.ts]
autonomous: true
---

<objective>
Create foundational SVG components for diagram rendering.

Purpose: Establish the base layer for all visualization components with proper SVG handling, viewBox management, and responsive behavior.
Output: DiagramCanvas wrapper and SVGContainer with zoom/pan capabilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-SUMMARY.md

# Available libraries (from Phase 1):
# - D3.js 7.9 for SVG manipulation
# - GSAP 3.14 for animations
# - LayerCake 10.0 for data visualization

# Design system components:
@src/lib/components/ui/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SVGContainer component with viewBox management</name>
  <files>src/lib/components/diagrams/SVGContainer.svelte</files>
  <action>
Create a reusable SVG container component:

```svelte
<script lang="ts">
  import { onMount } from 'svelte';

  let {
    width = 800,
    height = 600,
    padding = 40,
    preserveAspectRatio = 'xMidYMid meet',
    class: className = '',
    children
  }: {
    width?: number;
    height?: number;
    padding?: number;
    preserveAspectRatio?: string;
    class?: string;
    children: import('svelte').Snippet;
  } = $props();

  let containerRef: HTMLDivElement;
  let actualWidth = $state(width);
  let actualHeight = $state(height);

  // Responsive: update dimensions based on container
  onMount(() => {
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        actualWidth = entry.contentRect.width || width;
        // Maintain aspect ratio
        actualHeight = (actualWidth / width) * height;
      }
    });

    resizeObserver.observe(containerRef);
    return () => resizeObserver.disconnect();
  });
</script>

<div bind:this={containerRef} class="w-full {className}">
  <svg
    viewBox="0 0 {width} {height}"
    {preserveAspectRatio}
    width={actualWidth}
    height={actualHeight}
    class="block"
  >
    <g transform="translate({padding}, {padding})">
      {@render children()}
    </g>
  </svg>
</div>
```

Features:
- Responsive width based on container
- Maintains aspect ratio
- Configurable padding for content margin
- Proper viewBox for scaling
- Dark mode compatible (no hardcoded colors)
  </action>
  <verify>Component renders an SVG that scales with container width</verify>
  <done>SVGContainer with responsive viewBox management</done>
</task>

<task type="auto">
  <name>Task 2: Create DiagramCanvas with optional zoom/pan</name>
  <files>src/lib/components/diagrams/DiagramCanvas.svelte</files>
  <action>
Create a diagram canvas wrapper that adds optional zoom/pan using D3:

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import * as d3 from 'd3';
  import SVGContainer from './SVGContainer.svelte';

  let {
    width = 800,
    height = 600,
    padding = 40,
    zoomable = false,
    minZoom = 0.5,
    maxZoom = 3,
    class: className = '',
    children
  }: {
    width?: number;
    height?: number;
    padding?: number;
    zoomable?: boolean;
    minZoom?: number;
    maxZoom?: number;
    class?: string;
    children: import('svelte').Snippet;
  } = $props();

  let svgElement: SVGSVGElement;
  let transform = $state({ x: 0, y: 0, k: 1 });

  onMount(() => {
    if (zoomable && svgElement) {
      const zoom = d3.zoom<SVGSVGElement, unknown>()
        .scaleExtent([minZoom, maxZoom])
        .on('zoom', (event) => {
          transform = {
            x: event.transform.x,
            y: event.transform.y,
            k: event.transform.k
          };
        });

      d3.select(svgElement).call(zoom);
    }
  });
</script>

<div class="relative {className}">
  <SVGContainer {width} {height} {padding}>
    {#snippet children()}
      <g
        transform="translate({transform.x}, {transform.y}) scale({transform.k})"
        bind:this={svgElement}
      >
        {@render children()}
      </g>
    {/snippet}
  </SVGContainer>

  {#if zoomable}
    <div class="absolute bottom-2 right-2 flex gap-1">
      <button
        onclick={() => transform.k = Math.min(transform.k * 1.2, maxZoom)}
        class="p-1 bg-white dark:bg-slate-700 rounded shadow text-sm"
        aria-label="Zoom in"
      >+</button>
      <button
        onclick={() => transform.k = Math.max(transform.k / 1.2, minZoom)}
        class="p-1 bg-white dark:bg-slate-700 rounded shadow text-sm"
        aria-label="Zoom out"
      >−</button>
      <button
        onclick={() => transform = { x: 0, y: 0, k: 1 }}
        class="p-1 bg-white dark:bg-slate-700 rounded shadow text-sm"
        aria-label="Reset zoom"
      >⟲</button>
    </div>
  {/if}
</div>
```

Features:
- Optional zoom/pan with D3 zoom behavior
- Zoom controls (in, out, reset)
- Min/max zoom limits
- Transform state management
- Wraps SVGContainer for consistency
  </action>
  <verify>Diagram canvas renders, zoom controls work when zoomable=true</verify>
  <done>DiagramCanvas with optional D3 zoom/pan functionality</done>
</task>

<task type="auto">
  <name>Task 3: Create diagram components barrel export</name>
  <files>src/lib/components/diagrams/index.ts</files>
  <action>
Create barrel export for diagram components:

```typescript
// Base components
export { default as SVGContainer } from './SVGContainer.svelte';
export { default as DiagramCanvas } from './DiagramCanvas.svelte';

// Types for diagrams (will be expanded in subsequent plans)
export interface DiagramNode {
  id: string;
  label: string;
  type: 'treatment' | 'control' | 'confounder' | 'outcome' | 'variable';
  x: number;
  y: number;
}

export interface DiagramEdge {
  id: string;
  source: string;
  target: string;
  label?: string;
  style?: 'solid' | 'dashed';
}

export interface DiagramData {
  nodes: DiagramNode[];
  edges: DiagramEdge[];
}
```

This provides a clean import path and defines the core types for diagram data.
  </action>
  <verify>Import from $lib/components/diagrams works</verify>
  <done>Barrel export with base components and diagram types</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run dev` starts without errors
- [ ] `npm run build` succeeds
- [ ] SVGContainer renders responsive SVG
- [ ] DiagramCanvas zoom controls work
- [ ] Types are properly exported
</verification>

<success_criteria>
- All tasks completed
- SVG components are responsive
- Zoom/pan works with D3
- Ready for node/edge components in 04-02
</success_criteria>

<output>
After completion, create `.planning/phases/04-visualization-engine/04-01-SUMMARY.md`
</output>
