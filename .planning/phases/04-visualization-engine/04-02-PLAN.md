---
phase: 04-visualization-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/components/diagrams/Node.svelte, src/lib/components/diagrams/Edge.svelte, src/lib/components/diagrams/index.ts]
autonomous: true
---

<objective>
Create Node and Edge components for causal graph rendering.

Purpose: Build the visual primitives that represent variables (nodes) and causal relationships (edges) in diagrams.
Output: Node component with semantic type variants, Edge component with arrow rendering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Design system colors from Phase 2:
# --color-treatment: green (intervention)
# --color-control: blue (baseline)
# --color-confounder: red (bias source)
# --color-outcome: purple (dependent var)
# --color-arrow: gray (causal links)

@src/app.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Node component with semantic variants</name>
  <files>src/lib/components/diagrams/Node.svelte</files>
  <action>
Create a Node component for diagram vertices:

```svelte
<script lang="ts">
  import type { DiagramNode } from './index';

  let {
    node,
    selected = false,
    onClick
  }: {
    node: DiagramNode;
    selected?: boolean;
    onClick?: (node: DiagramNode) => void;
  } = $props();

  // Node type to color mapping using CSS variables
  const typeColors = {
    treatment: 'var(--color-treatment)',
    control: 'var(--color-control)',
    confounder: 'var(--color-confounder)',
    outcome: 'var(--color-outcome)',
    variable: 'var(--color-arrow)'
  };

  const nodeRadius = 30;
  const color = typeColors[node.type];
</script>

<g
  transform="translate({node.x}, {node.y})"
  class="cursor-pointer"
  onclick={() => onClick?.(node)}
  onkeydown={(e) => e.key === 'Enter' && onClick?.(node)}
  role="button"
  tabindex="0"
  aria-label="{node.label} ({node.type})"
>
  <!-- Node circle -->
  <circle
    r={nodeRadius}
    fill={color}
    fill-opacity="0.2"
    stroke={color}
    stroke-width={selected ? 3 : 2}
    class="transition-all duration-200"
  />

  <!-- Selection ring -->
  {#if selected}
    <circle
      r={nodeRadius + 5}
      fill="none"
      stroke={color}
      stroke-width="2"
      stroke-dasharray="4 2"
      class="animate-pulse"
    />
  {/if}

  <!-- Node label -->
  <text
    text-anchor="middle"
    dominant-baseline="central"
    class="text-sm font-medium fill-slate-900 dark:fill-slate-100 pointer-events-none"
  >
    {node.label}
  </text>

  <!-- Type indicator (small badge below) -->
  <text
    y={nodeRadius + 15}
    text-anchor="middle"
    class="text-xs fill-slate-500 dark:fill-slate-400 pointer-events-none"
  >
    {node.type}
  </text>
</g>
```

Features:
- Semantic colors from design system (treatment=green, control=blue, etc.)
- Selection state with animated ring
- Accessible (keyboard navigation, aria-label)
- Type indicator below node
- Dark mode compatible via CSS variables
  </action>
  <verify>Node renders with correct color based on type</verify>
  <done>Node component with semantic type variants and selection state</done>
</task>

<task type="auto">
  <name>Task 2: Create Edge component with arrow rendering</name>
  <files>src/lib/components/diagrams/Edge.svelte</files>
  <action>
Create an Edge component for causal arrows:

```svelte
<script lang="ts">
  import type { DiagramEdge, DiagramNode } from './index';

  let {
    edge,
    sourceNode,
    targetNode,
    selected = false,
    onClick
  }: {
    edge: DiagramEdge;
    sourceNode: DiagramNode;
    targetNode: DiagramNode;
    selected?: boolean;
    onClick?: (edge: DiagramEdge) => void;
  } = $props();

  const nodeRadius = 30;
  const arrowSize = 10;

  // Calculate edge path with offset from node centers
  const dx = targetNode.x - sourceNode.x;
  const dy = targetNode.y - sourceNode.y;
  const length = Math.sqrt(dx * dx + dy * dy);
  const unitX = dx / length;
  const unitY = dy / length;

  // Start and end points (offset by node radius)
  const startX = sourceNode.x + unitX * nodeRadius;
  const startY = sourceNode.y + unitY * nodeRadius;
  const endX = targetNode.x - unitX * (nodeRadius + arrowSize);
  const endY = targetNode.y - unitY * (nodeRadius + arrowSize);

  // Control point for slight curve (optional)
  const midX = (startX + endX) / 2;
  const midY = (startY + endY) / 2;

  // Arrow marker ID (unique per edge)
  const markerId = `arrow-${edge.id}`;

  const strokeStyle = edge.style === 'dashed' ? '8 4' : 'none';
</script>

<g
  class="cursor-pointer"
  onclick={() => onClick?.(edge)}
  role="button"
  tabindex="0"
  aria-label="Edge from {sourceNode.label} to {targetNode.label}"
>
  <!-- Arrow marker definition -->
  <defs>
    <marker
      id={markerId}
      viewBox="0 0 10 10"
      refX="9"
      refY="5"
      markerWidth={arrowSize}
      markerHeight={arrowSize}
      orient="auto-start-reverse"
    >
      <path
        d="M 0 0 L 10 5 L 0 10 z"
        fill="var(--color-arrow)"
        class={selected ? 'fill-blue-500' : ''}
      />
    </marker>
  </defs>

  <!-- Edge line -->
  <line
    x1={startX}
    y1={startY}
    x2={endX}
    y2={endY}
    stroke="var(--color-arrow)"
    stroke-width={selected ? 3 : 2}
    stroke-dasharray={strokeStyle}
    marker-end="url(#{markerId})"
    class="transition-all duration-200"
  />

  <!-- Edge label (if provided) -->
  {#if edge.label}
    <text
      x={midX}
      y={midY - 10}
      text-anchor="middle"
      class="text-xs fill-slate-600 dark:fill-slate-400 pointer-events-none"
    >
      {edge.label}
    </text>
  {/if}

  <!-- Invisible wider hitbox for easier clicking -->
  <line
    x1={startX}
    y1={startY}
    x2={endX}
    y2={endY}
    stroke="transparent"
    stroke-width="15"
  />
</g>
```

Features:
- Proper arrow markers at edge end
- Offset from node circles
- Optional edge labels
- Dashed style support for uncertain relationships
- Wider invisible hitbox for easier selection
- Dark mode via CSS variables
  </action>
  <verify>Edge renders arrow from source to target node</verify>
  <done>Edge component with arrow markers and label support</done>
</task>

<task type="auto">
  <name>Task 3: Update barrel export with Node and Edge</name>
  <files>src/lib/components/diagrams/index.ts</files>
  <action>
Update the barrel export to include Node and Edge components:

```typescript
// Base components
export { default as SVGContainer } from './SVGContainer.svelte';
export { default as DiagramCanvas } from './DiagramCanvas.svelte';

// Graph primitives
export { default as Node } from './Node.svelte';
export { default as Edge } from './Edge.svelte';

// Types for diagrams
export interface DiagramNode {
  id: string;
  label: string;
  type: 'treatment' | 'control' | 'confounder' | 'outcome' | 'variable';
  x: number;
  y: number;
}

export interface DiagramEdge {
  id: string;
  source: string;
  target: string;
  label?: string;
  style?: 'solid' | 'dashed';
}

export interface DiagramData {
  nodes: DiagramNode[];
  edges: DiagramEdge[];
}

// Helper to get node by ID
export function getNodeById(nodes: DiagramNode[], id: string): DiagramNode | undefined {
  return nodes.find(n => n.id === id);
}
```

Note: If SVGContainer and DiagramCanvas don't exist yet (04-01 not complete), the export will work once they're created. Plans run in parallel.
  </action>
  <verify>All components exported from barrel file</verify>
  <done>Complete barrel export with primitives and types</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run dev` starts without errors
- [ ] `npm run build` succeeds
- [ ] Node renders with correct semantic colors
- [ ] Edge renders with arrow markers
- [ ] Components are accessible
</verification>

<success_criteria>
- All tasks completed
- Node types use design system colors
- Edges have proper arrow rendering
- Components work standalone
- Ready for causal diagram composition in 04-03
</success_criteria>

<output>
After completion, create `.planning/phases/04-visualization-engine/04-02-SUMMARY.md`
</output>
