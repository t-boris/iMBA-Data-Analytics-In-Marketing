---
phase: 04-visualization-engine
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified: [src/lib/components/diagrams/CausalDiagram.svelte, src/lib/components/diagrams/DAGDiagram.svelte, src/lib/components/diagrams/TreatmentEffectDiagram.svelte, src/lib/components/diagrams/index.ts]
autonomous: true
---

<objective>
Create high-level causal diagram components for educational visualizations.

Purpose: Build reusable diagram components that compose Node and Edge primitives into meaningful causal visualizations.
Output: CausalDiagram (generic), DAGDiagram (directed acyclic graph), TreatmentEffectDiagram (treatment/outcome with confounders).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs:
@.planning/phases/04-visualization-engine/04-01-SUMMARY.md
@.planning/phases/04-visualization-engine/04-02-SUMMARY.md

# Module 1 topics that need visualizations:
# - Confounding variables and spurious correlation
# - Treatment effects and causal paths
# - Selection bias diagrams
# - DAGs for causal inference
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generic CausalDiagram component</name>
  <files>src/lib/components/diagrams/CausalDiagram.svelte</files>
  <action>
Create a flexible CausalDiagram component that renders any diagram data:

```svelte
<script lang="ts">
  import { DiagramCanvas, Node, Edge, getNodeById } from './index';
  import type { DiagramData, DiagramNode, DiagramEdge } from './index';

  let {
    data,
    width = 600,
    height = 400,
    zoomable = false,
    title,
    description,
    onNodeClick,
    onEdgeClick,
    selectedNodeId,
    selectedEdgeId,
    class: className = ''
  }: {
    data: DiagramData;
    width?: number;
    height?: number;
    zoomable?: boolean;
    title?: string;
    description?: string;
    onNodeClick?: (node: DiagramNode) => void;
    onEdgeClick?: (edge: DiagramEdge) => void;
    selectedNodeId?: string;
    selectedEdgeId?: string;
    class?: string;
  } = $props();
</script>

<figure class="diagram-figure {className}">
  {#if title}
    <figcaption class="text-center mb-2">
      <span class="font-semibold text-slate-900 dark:text-white">{title}</span>
      {#if description}
        <p class="text-sm text-slate-600 dark:text-slate-400">{description}</p>
      {/if}
    </figcaption>
  {/if}

  <DiagramCanvas {width} {height} {zoomable}>
    <!-- Render edges first (below nodes) -->
    {#each data.edges as edge (edge.id)}
      {@const sourceNode = getNodeById(data.nodes, edge.source)}
      {@const targetNode = getNodeById(data.nodes, edge.target)}
      {#if sourceNode && targetNode}
        <Edge
          {edge}
          {sourceNode}
          {targetNode}
          selected={selectedEdgeId === edge.id}
          onClick={onEdgeClick}
        />
      {/if}
    {/each}

    <!-- Render nodes on top -->
    {#each data.nodes as node (node.id)}
      <Node
        {node}
        selected={selectedNodeId === node.id}
        onClick={onNodeClick}
      />
    {/each}
  </DiagramCanvas>
</figure>
```

Features:
- Takes generic DiagramData (nodes + edges)
- Optional title and description
- Selection callbacks for interactivity
- Edges rendered below nodes
- Zoomable option
  </action>
  <verify>CausalDiagram renders nodes and edges from data</verify>
  <done>Generic CausalDiagram component for any diagram data</done>
</task>

<task type="auto">
  <name>Task 2: Create DAGDiagram with auto-layout</name>
  <files>src/lib/components/diagrams/DAGDiagram.svelte</files>
  <action>
Create a DAG-specific diagram with automatic hierarchical layout:

```svelte
<script lang="ts">
  import CausalDiagram from './CausalDiagram.svelte';
  import type { DiagramData, DiagramNode, DiagramEdge } from './index';

  let {
    nodes,
    edges,
    width = 600,
    height = 400,
    title = 'Directed Acyclic Graph',
    description,
    class: className = ''
  }: {
    nodes: Array<Omit<DiagramNode, 'x' | 'y'>>;
    edges: DiagramEdge[];
    width?: number;
    height?: number;
    title?: string;
    description?: string;
    class?: string;
  } = $props();

  // Simple hierarchical layout algorithm
  function layoutNodes(
    nodes: Array<Omit<DiagramNode, 'x' | 'y'>>,
    edges: DiagramEdge[],
    width: number,
    height: number
  ): DiagramNode[] {
    // Find root nodes (no incoming edges)
    const hasIncoming = new Set(edges.map(e => e.target));
    const roots = nodes.filter(n => !hasIncoming.has(n.id));

    // BFS to assign levels
    const levels = new Map<string, number>();
    const queue = roots.map(n => ({ id: n.id, level: 0 }));

    while (queue.length > 0) {
      const { id, level } = queue.shift()!;
      if (levels.has(id)) continue;
      levels.set(id, level);

      // Find children
      const children = edges.filter(e => e.source === id).map(e => e.target);
      children.forEach(childId => {
        if (!levels.has(childId)) {
          queue.push({ id: childId, level: level + 1 });
        }
      });
    }

    // Group by level and position
    const maxLevel = Math.max(...levels.values(), 0);
    const levelGroups = new Map<number, string[]>();

    levels.forEach((level, id) => {
      if (!levelGroups.has(level)) levelGroups.set(level, []);
      levelGroups.get(level)!.push(id);
    });

    // Calculate positions
    const padding = 60;
    const usableWidth = width - padding * 2;
    const usableHeight = height - padding * 2;

    return nodes.map(node => {
      const level = levels.get(node.id) ?? 0;
      const nodesAtLevel = levelGroups.get(level) ?? [node.id];
      const indexAtLevel = nodesAtLevel.indexOf(node.id);

      const x = padding + (usableWidth / (maxLevel + 1)) * level + (usableWidth / (maxLevel + 1)) / 2;
      const y = padding + (usableHeight / (nodesAtLevel.length + 1)) * (indexAtLevel + 1);

      return { ...node, x, y };
    });
  }

  const layoutData = $derived<DiagramData>({
    nodes: layoutNodes(nodes, edges, width, height),
    edges
  });
</script>

<CausalDiagram
  data={layoutData}
  {width}
  {height}
  {title}
  {description}
  class={className}
/>
```

Features:
- Automatic hierarchical layout (left-to-right)
- Takes nodes without x/y positions
- Calculates positions based on graph structure
- Handles multiple root nodes
  </action>
  <verify>DAGDiagram auto-positions nodes based on edges</verify>
  <done>DAGDiagram with automatic hierarchical layout</done>
</task>

<task type="auto">
  <name>Task 3: Create TreatmentEffectDiagram preset</name>
  <files>src/lib/components/diagrams/TreatmentEffectDiagram.svelte</files>
  <action>
Create a specialized diagram for treatment effect visualization:

```svelte
<script lang="ts">
  import CausalDiagram from './CausalDiagram.svelte';
  import type { DiagramData } from './index';

  let {
    treatment = 'Treatment',
    outcome = 'Outcome',
    confounders = [] as string[],
    showDirectEffect = true,
    showConfoundingPaths = true,
    width = 500,
    height = 350,
    title,
    description,
    class: className = ''
  }: {
    treatment?: string;
    outcome?: string;
    confounders?: string[];
    showDirectEffect?: boolean;
    showConfoundingPaths?: boolean;
    width?: number;
    height?: number;
    title?: string;
    description?: string;
    class?: string;
  } = $props();

  // Build diagram data from props
  const data = $derived<DiagramData>(() => {
    const nodes = [
      { id: 'treatment', label: treatment, type: 'treatment' as const, x: 100, y: height / 2 },
      { id: 'outcome', label: outcome, type: 'outcome' as const, x: width - 140, y: height / 2 }
    ];

    const edges = [];

    // Direct treatment effect
    if (showDirectEffect) {
      edges.push({ id: 'direct', source: 'treatment', target: 'outcome', label: 'Causal Effect' });
    }

    // Add confounders
    confounders.forEach((conf, i) => {
      const confId = `conf-${i}`;
      const yPos = 80 + (i * 80);

      nodes.push({
        id: confId,
        label: conf,
        type: 'confounder' as const,
        x: width / 2,
        y: yPos
      });

      if (showConfoundingPaths) {
        edges.push({ id: `conf-t-${i}`, source: confId, target: 'treatment', style: 'dashed' as const });
        edges.push({ id: `conf-o-${i}`, source: confId, target: 'outcome', style: 'dashed' as const });
      }
    });

    return { nodes, edges };
  });
</script>

<CausalDiagram
  data={data()}
  {width}
  {height}
  title={title ?? 'Treatment Effect Diagram'}
  {description}
  class={className}
/>
```

Features:
- Pre-configured for treatment/outcome/confounder visualization
- Customizable labels
- Toggle direct effect path
- Toggle confounding paths
- Multiple confounders supported
- Educational descriptions built-in
  </action>
  <verify>TreatmentEffectDiagram shows treatment, outcome, and confounders</verify>
  <done>TreatmentEffectDiagram preset for causal inference teaching</done>
</task>

<task type="auto">
  <name>Task 4: Update barrel export with all diagram components</name>
  <files>src/lib/components/diagrams/index.ts</files>
  <action>
Update barrel export with all new components:

```typescript
// Base components
export { default as SVGContainer } from './SVGContainer.svelte';
export { default as DiagramCanvas } from './DiagramCanvas.svelte';

// Graph primitives
export { default as Node } from './Node.svelte';
export { default as Edge } from './Edge.svelte';

// High-level diagram components
export { default as CausalDiagram } from './CausalDiagram.svelte';
export { default as DAGDiagram } from './DAGDiagram.svelte';
export { default as TreatmentEffectDiagram } from './TreatmentEffectDiagram.svelte';

// Types
export interface DiagramNode {
  id: string;
  label: string;
  type: 'treatment' | 'control' | 'confounder' | 'outcome' | 'variable';
  x: number;
  y: number;
}

export interface DiagramEdge {
  id: string;
  source: string;
  target: string;
  label?: string;
  style?: 'solid' | 'dashed';
}

export interface DiagramData {
  nodes: DiagramNode[];
  edges: DiagramEdge[];
}

// Helpers
export function getNodeById(nodes: DiagramNode[], id: string): DiagramNode | undefined {
  return nodes.find(n => n.id === id);
}
```
  </action>
  <verify>All diagram components exported from barrel</verify>
  <done>Complete barrel export with all visualization components</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run dev` starts without errors
- [ ] `npm run build` succeeds
- [ ] CausalDiagram renders any diagram data
- [ ] DAGDiagram auto-layouts nodes
- [ ] TreatmentEffectDiagram shows treatment effect structure
</verification>

<success_criteria>
- All tasks completed
- High-level components compose primitives correctly
- Auto-layout works for DAGs
- TreatmentEffect preset is education-ready
- Ready for visual verification in 04-04
</success_criteria>

<output>
After completion, create `.planning/phases/04-visualization-engine/04-03-SUMMARY.md`
</output>
